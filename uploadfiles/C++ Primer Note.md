1. 在使用范围for循环改变字符串等容器中的值时，必须把循环变量定义成引用类型：`for(auto &c: str)`

   

2. 如果循环体内部有改变vector容量的语句，则不能使用范围for循环

   

3. 标准库容器的迭代器都定义了==和！=，但是它们中的大多数都没有定义>和<运算符

   

4. `Int (*Parray)[10]=&arr;`	//Parray指向一个含有10个整数的数组

​	   要理解数组的声明，最好从数组名字开始从内往外的阅读。



5. ```c++
   int ia[]={0,1,2,3,4,5,6,7,8,9};
   auto ia2(ia);	//ia2是一个整型指针，指向ia的第一个数组
   decltype(ia) ia3={0,1,2,3,4,5,6,7,8,9}	//decltype(ia)返回的类型是由10个整数构成的数组
   int *p=&ia[0];
   ia3=p;	//这是错误的，因为不能把整型指针赋值给数组
   ```



6. ```c++
   int a[10];
   int *e=&a[10]; //可以通过这种方式获取尾后指针，但不能通过尾后指针执行解引用或递增操作
   int *beg=begin(a);
   int *last=end(a); //通过库函数获取尾后指针
   ```



7. ```c++
   int a[10];
   int *p=&a[3];
   int k=p[-2]; //内置类型的下标运算符可以处理负值，但要求结果指针依旧指向原来的数组中的元素
   ```



8. 二维数组的范围for语句遍历

   ```c++
   int ia[3][4]={0};
   
   for(auto &row: ia){	//此处使用引用，否则row会退化为指向整型的指针，导致内层循环编译失败
   	for(auto col: row)//若要改变元素的值，需要声明为引用类型
           cout<<col<<endl;
   }
   
   范围for循环只是将变量初始化为表达式对应位置的元素值，因此要改变内容需要使用引用类型
   范围for循环处理多维数组时，除了最内层，其余循环的控制变量都应该是引用类型
       
   P114页
   ```



9. 左值与右值

   ```
   当一个对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。
   一个左值可以被当做右值来使用，但是右值不可以被当作左值使用。
   
   decltype作用于左值得到一个左值类型的引用，作用于右值得到一个指向右值类型的指针。
   ```



10. 取模运算m%n的结果的符号与m一致，除非m%n的值为0。



11. 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算结果时左值，否则运算结果是右值。



12. 移位运算符的优先级低于算术运算符，但高于关系运算符、赋值运算符和条件运算符。



13. `sizeof expr`返回的是表达式结果类型的大小，但并不会计算表达式，因此就算表达式无效也不会错误。

    sizeof不会把数组转化成指针来处理（已经转化成指针的除外）。

    对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素占用了多少空间。



14. 逗号运算符的结果是右侧表达式的值



15. 指向成员选择的指针

    ```
    对于Test类中的函数或者变量，在函数外定义指针int Test::*p = &Test::ma;
    指针p不能单独使用，需要通过Test类的对象调用
    Test test;
    test.*p=10;
    等价于test.ma=10;
    对于->*的使用是一样的方法。
    ```



16. case的标签必须是整型常量表达式



17. 不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置，因此如果想要在case标签后初始化变量，需要将该标签后的语句用{}包含起来，使得其中的变量的作用范围不会超过该标签的范围。注意goto语句也不能跳过变量的初始化语句。
